// функция для вывода в консоль результатов работы фукнций в 1-5 заданиях
const printResult = (result) => {
  console.log(result);
}
// 1st task - Написать метод/функцию, который/которая на вход принимает массив городов. В качестве результата возвращает строку, где города разделены запятыми, а в конце стоит точка. Например, «Москва, Санкт-Петербург, Воронеж.» 
const cities = ['Moscow', 'St. Petersburg', 'Voronezh', 'Ryazan', 'Penza', 'Saratov', 'Kazan', 'Ufa', 'Yekaterinburg', 'Tambov'];
//////////          I variant        //////////
// // создаем результирующую строку
// let result = '';
// const printString = (arr) => {
// // перебираем массив с городами
//   arr.forEach((elem, index) => {
// // ЕСЛИ элемент по индексу последний, то ставим точку в конце строки
//     index === arr.length-1 ? result += `${elem}.` : 
// // ИНАЧЕ если элемент по индексу не последний (меньше длины массива), то ставим запятую после элемента
//       index < arr.length ? result += `${elem}, ` : ''
//   })
// }
// printResult('1st task');
// printString(cities);
// printResult(result);
//////////          II variant        //////////
// преобразование массива в строку методом join с разделителем (запятая с пробелом) при помощи шаблонной строки с подставлением точки в конце строки
const joinArray = (arr) => `${arr.join(', ')}.`;
printResult('1st task');
printResult(joinArray(cities));
printResult('____________________________________\n\n\n');


// 2nd task - Написать метод/функцию, который/которая на вход принимает число (float), а на выходе получает число, округленное до пятерок. Пример: 27 => 25, 27.8 => 30, 41.7 => 40.
// округляем деленное переданное число на 5 для получения целой части от числа, и умножаем на 5 для получения округленного до пятерок числа
const roundNumber = (number) => 5*Math.round(number/5);
printResult('2nd task')
printResult(roundNumber(27));
printResult(roundNumber(27.8));
printResult(roundNumber(41.7));
printResult('____________________________________\n\n\n');


// 3rd task - Написать метод/функцию, который/которая на вход принимает число (int), а на выходе выдает слово “компьютер” в падеже, соответствующем указанному количеству. Например, «25 компьютеров», «41 компьютер», «1048 компьютеров».
const checkAmount = (number) => {
  // на всякий случай, приведение к целочисленному значению, на случай, если всё-таки будет передано не int 
  number = Math.floor(number);
  // получаем последнюю цифру числа, путем приведения числа к строке и получения последнего элемента строки по индексу длины строки
  const lastDigit = +number.toString().split('')[number.toString().length-1];
  // ЕСЛИ последняя цифра равна 1, то нулевое окончание
  return lastDigit === 1 ? `${number} компьютер` :
  // ИНАЧЕ если последняя цифра от 2 до 4, то окончание "а"
    lastDigit >= 2 && lastDigit <= 4 ? `${number} компьютера` :
    // ИНАЧЕ если последняя цифра 0 или от 5 до 9, то окончание "ов"
      lastDigit === 0 || lastDigit >= 5 && lastDigit <= 9 ? `${number} компьютеров` : '';
}
printResult('3rd task')
printResult(checkAmount(25))
printResult(checkAmount(41))
printResult(checkAmount(1048))
// printResult(checkAmount(32))
// printResult(checkAmount(21.8))
// printResult(checkAmount(0))
printResult('____________________________________\n\n\n');


// 4th task - Написать метод/функцию, который/которая на вход принимает целое число, а на выходе возвращает то, является ли число простым (не имеет делителей кроме 1 и самого себя).
const checkSimpleNumber = (number) => {
  const simple = `${number} является простым числом`;
  const noSimple = `${number} не является простым числом, так как является составным`;
  // значение-маркер, которое устанавливает, что по умолчанию число простое
  let isSimple = true;
  // перебираем все делителти числа в цикле, начиная с 2 и не считая проверяемое на простоту число
  for (let i = 2; i < number; i++) {
    // ЕСЛИ при делении находится хоть один делитель без остатка, то прерываем цикл и присваиваем маркеру противоположное значение - НЕ ПРОСТОЕ, так как число уже явно является простым так как делится не только на единицу(исключена из цикла) и само себя (исключено из цикла) без остатка
    if (number % i === 0) {
      isSimple = false;
      break;
    }
  }
  // возвращаем значение, что число простое, ЕСЛИ маркер true ИНАЧЕ не простое число
  return isSimple ? simple : noSimple;
}
// получаем рандомное число, чтобы проверить его на простоту
const getRandomNumber = (min, max) => Math.floor(min + Math.random() * (max + 1 - min));
printResult('4th task');
printResult(checkSimpleNumber(getRandomNumber(2, 1000)));
printResult('____________________________________\n\n\n');


// 5th task - Написать метод, который определяет, какие элементы присутствуют в двух экземплярах в каждом из массивов (= в двух и более, причем в каждом). На вход подаются два массива. На выходе массив с необходимыми совпадениями. Пример: [7, 17, 1, 9, 1, 17, 56, 56, 23], [56, 17, 17, 1, 23, 34, 23, 1, 8, 1] На выходе [1, 17]
const firstArray = [7, 17, 1, 9, 1, 17, 56, 56, 23];
const secondArray = [56, 17, 17, 1, 23, 34, 23, 1, 8, 1];
const sameAmountInArrays = (arr1, arr2) => {
  const result = [];
  const getArray = (arr) => {
    const result = [];
    const sameNumbers = [];
    const sameNumbersAmount = [];
    let prev;
    arr.forEach(elem => {
      // ЕСЛИ текущий элемент не равен предыдущему, то 
      if (elem !== prev) {
        // добавить этот элемент как уникальный в массив с одинаковыми числами 
        sameNumbers.push(elem);
        // и присвоить ему количество вхождения равное 1 разу
        sameNumbersAmount.push(1);
      // ИНАЧЕ (если текущий элемент равен предыдущему, то есть он уже не уникален и существует в массиве), то взять количество его вхождений в массиве с количеством вхождений одинаковых чисел и увеличить на один
      } else {
        sameNumbersAmount[sameNumbersAmount.length - 1]++;
      } 
      // обновляем предыдущее текущим, так как выходим из условия цикла и данное значение теперь является предудщим относительно следующего элемента массива
      prev = elem;
    })
    // добавляем в промежуточный результирующий массив объекты с элементами и их количеством
    sameNumbers.forEach((elem, index) => {
      result.push({number: elem, amount: sameNumbersAmount[index]});
    })
    // возвращаем отфильтрованный массив объектов, где количество уникального элемента больше либо равно 2 (по условию задачи)
    return result.filter(i => i.amount >= 2);
  }
  // перебираем первый промежуточный результирующий массив 
  getArray(arr1.sort((a,b) => a - b)).forEach(elem => {
    // второй промежуточный результирующий массив
    getArray(arr2.sort((a,b) => a - b)).forEach(item => {
      // и в случае, ЕСЛИ количество уникальных элементов в обоих массивах равны, то добавляем этот элемент в результирующий массив
      if (elem.number === item.number) {
        result.push(elem.number)
      }
    })
  })
  return result; 
}
printResult('5th task');
printResult(sameAmountInArrays(firstArray, secondArray));